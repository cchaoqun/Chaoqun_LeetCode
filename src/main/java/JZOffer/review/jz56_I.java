package JZOffer.review;

/**剑指 Offer 56 - I. 数组中数字出现的次数
 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。



 示例 1：

 输入：nums = [4,1,4,6]
 输出：[1,6] 或 [6,1]
 示例 2：

 输入：nums = [1,2,10,4,1,4,3,3]
 输出：[2,10] 或 [10,2]


 限制：

 2 <= nums.length <= 10000
 * @author Chaoqun Cheng
 * @date 2021-07-2021/7/29-16:03
 */

public class jz56_I {
    public int[] singleNumbers(int[] nums) {
        /**
         任何数和自己异或的结果都是0 x^x = 0
         任何数和0 异或的结果都是自己 x^0 = x
         一个数组中如果只有一个数字出现一次其他都出现两次, 数组所有元素异或的结果就是出现一次的那个匀速
         那么数组只有两个数x,y出现一次, 其余都出现两次, 那么数组所有元素异或的结果就是x^y
         因为x!=y 所以两个数至少在其中某bit上不同, 所以这个不同的bit在最后的结构中是1
         我们想找到从左到右第一个为1的bit 00001000为例 k
         将整个数组根据与k按位与的结果不同分成两个子数组a, b
         相同的元素与k异或的结果一定一样
         但是 x^y 因为在k bit上为1,
         所以一定一个是0一个是1, 所以与k异或的结果一定不同, 所以一定被分到了两个分组
         最后两个分组的元素异或得到的两个数就是整个数组中只出现一次的2个数
         */
        // 求两个出现一次的数的异或结果
        int xor = 0;
        for(int i : nums){
            xor ^= i;
        }
        // 求两个数异或结果中的第一个为1的bit
        int k = 1;
        while((k&xor)==0){
            k<<=1;
        }
        // 将数组所有的数与k按位与分成两组
        int a = 0, b=0;
        for(int i : nums){
            if((i&k)!=0){
                a ^= i;
            }else{
                b ^= i;
            }
        }
        return new int[]{a,b};
    }
}
